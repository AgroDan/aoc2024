# Day 21: Keypad Conundrum

Oh my sweet baby Jesus, this was without a doubt the most difficult challenge so far. The concept was easy enough to understand, but the implementation put my smooth brain through its paces. Just thinking about how one robot has to control another robot which controls another robot and you had to find the most efficient method to the end goal was just so difficult to conceptualize. Without hindsight, I spent so much time trying to find the logic to why you would want to favor moving one way over another, and when I thought I had it it turns out there were challenges that came to light further down the chain that only show if you recurse deep enough.

Ultimately I got through part one after I just shook off the edge cases that I kept trying to account for and do the silly brute-force method of just trying _every_ single possibility and returning the shortest length. It seemed easy enough to do if you just take it for what it's worth. My method for pathfinding was...unique, I'll admit. Was it breadth first search? I honestly don't know. Maybe? Possibly even A*? Actually it might be closer to A* because it chose the next path based on a smaller manhattan distance from its endpoint, so yeah I'm gonna go with A*. Also it didn't return anything, just populated all possible efficient paths into a string array that was referenced by a pointer. That was the best way I could come up with to return _all_ possible paths that were worth anything.

Then came part two. In typical Advent of Code rug-pull fashion, it turns out that I wasn't controlling 2 robots on a directional pad with 1 on a number pad, I was controlling _25_ robots on the directional pad. So now the complexity increased by an order of magnitude greater, exponentially so. Now the technique I used in part one just wouldn't cut it. In fact, if I just searched for the answer with 3 directional pad robots my computer would chug, so forget 25. In situations like this, it seems that the best method to accomplish this feat involves memoization. And I know that Python has a really neat trick using `functools.cache`, so I decided to implement my own version of that in Go. I'm sure there are other libraries that do this, but I wanted to make my own. Behold `utils.Cache`!

It's a wrapper function that surrounds another function and records its answer in a cache. If that function is called again with the same cache key, the wrapper function simply returns the stored result rather than re-compute the answer from scratch. For my methods, I chose to find every single possible directions a robot could take on a direction pad (such as the directions from `^` to `<`, from `A` to `>`, etc) and recurse itself all the way down to level 25, where it would compute the length of every possible choice direction you could go. After it computed a few, it was able to refer to the values it computed using the cache and skip through entire portions of the process, ultimately adding up the numbers that it needed, the complexity score. Then of course just multiplying it with the number of the door code, and voila!

It goes without saying that part two actually went _a lot_ faster than part one, even with the multiple layers. In total my code runs for a little over 5 seconds, and a large majority of the computational time was just running through part 1 the brute-force way. I could go back and change it, but at this point I'm just happy to be done with this one. Oh my poor brain.